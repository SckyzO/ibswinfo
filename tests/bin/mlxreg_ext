#!/usr/bin/env bash

# Intelligent mock for mlxreg_ext
# It reads tests/mocks/ibsw_dump.txt and extracts the corresponding response.

DUMP_FILE="$(dirname "${BASH_SOURCE[0]}")/../mocks/ibsw_dump.txt"

# Reconstruct the called command to find the corresponding block
# We look for --reg_name and flags --get/--show_reg/--indexes
REG_NAME=""
INDEXES=""
SHOW_REG=""
GET_FLAG=0

args=("$@")
for ((i=0; i<${#args[@]}; i++)); do
    case "${args[i]}" in
        --reg_name) REG_NAME="${args[i+1]}"; ((i++)) ;;
        --indexes) INDEXES="${args[i+1]}"; ((i++)) ;;
        --show_reg) SHOW_REG="${args[i+1]}"; ((i++)) ;;
        --get) GET_FLAG=1 ;;
    esac
done

SEARCH_PATTERN=""
if [[ -n "$SHOW_REG" ]]; then
    SEARCH_PATTERN="--show_reg $SHOW_REG"
elif [[ -n "$REG_NAME" ]]; then
    SEARCH_PATTERN="--reg_name $REG_NAME"
    [[ $GET_FLAG -eq 1 ]] && SEARCH_PATTERN="$SEARCH_PATTERN --get"
    [[ -n "$INDEXES" ]] && SEARCH_PATTERN="$SEARCH_PATTERN --indexes $INDEXES"
fi

# Extract the corresponding block with awk
# We want the content between the separation block following the command 
# and the next separation block or a double empty line.
awk -v pattern="$SEARCH_PATTERN" '
    BEGIN { found=0; block=0 }
    /^COMMAND:/ && index($0, pattern) {
        found=1
        next
    }
    found && /^=======/ {
        block++
        if (block == 2) { # We are after the table header
            next
        }
    }
    found && block >= 2 {
        if (/^=====/ || /^$/) {
            if (length($0) > 10 || /^$/) { # End of table or empty line
                exit
            }
        }
        # Do not print MFT informative messages
        if ($0 !~ /Sending access register/) {
            print $0
        }
    }
' "$DUMP_FILE"
